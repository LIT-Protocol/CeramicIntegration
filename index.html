<!DOCTYPE html>

<html>
  <head>
    <script type="module" src="functions.js"></script>
    <script type="module">
      import { ping } from "./functions.js";

      // document.body.innerHTML = ping();
    </script>

    <title>LIT Protocol /+ Ceramic Network Integration</title>

    <script
      onload="LitJsSdk.litJsSdkLoadedInALIT()"
      src="https://jscdn.litgateway.com/index.web.js"
    ></script>

    <script>
      const client = new LitJsSdk.LitNodeClient();
      client.connect();
      window.litNodeClient = client;

      async function encryptWithLit() {
        document.getElementById("mintingStatus").innerText =
          "Encrypting, please wait..";

        window.chain = document.getElementById("selectedChain").value;

        // window.tokenId = tokenId;
        // window.tokenAddress = tokenAddress;
        // window.authSig = authSig;

        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain: window.chain
        });

        // what shall be encrypted
        const aStringThatYouWishToEncrypt =
          "this is what I want to encrypt, for now.";

        // zip and encrypt
        const {
          encryptedZip,
          symmetricKey
        } = await LitJsSdk.zipAndEncryptString(aStringThatYouWishToEncrypt);

        // get access control conditions
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "ethereum",
            method: "eth_getBalance",
            parameters: [
              "0x20598860Da775F63ae75E1CD2cE0D462B8CEe4C7",
              "latest"
            ],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000"
            }
          }
        ];

        const encryptedSymmetricKey = await window.litNodeClient.saveEncryptionKey(
          {
            accessControlConditions,
            symmetricKey,
            authSig,
            chain
          }
        );

        // encryptedSymmetricKey, accessControlConditions and ofc the actual encryptedZip
        // all must be stored such to decrypt
        // console.log("encryptedSYMKEY: \n\n    ", encryptedSymmetricKey);
        // console.log("-----------------------------");
        // console.log(
        //   "accessControlConditions: \n\n    ",
        //   accessControlConditions
        // );
        // console.log("-----------------------------");
        // console.log("encryptedZip: \n\n    ", encryptedZip);

        // const data = await fetch("/verify?jwt=" + window.jwt).then(resp =>
        //   resp.json()
        // );
        // document.getElementById("verificationStatus").innerText =
        //   "Verified!  Response is \n" + JSON.stringify(data, null, 2);

        const dataACC = JSON.stringify(accessControlConditions);

        document.getElementById("mintingStatus").innerText =
          "Encrypted!    encryptedSYMKEY: \n\n    " +
          encryptedSymmetricKey +
          "\n\n" +
          "accessControlConditions: \n\n    " +
          dataACC +
          "\n\n" +
          "encryptedZip: \n\n    " +
          encryptedZip;

        // URL.createObjectURL(encryptedZip);

        window.accessControlConditionsSave = dataACC;
        window.encryptedSymmetricKeySave = encryptedSymmetricKey;
        window.encryptedZipSave = encryptedZip;
      }

      async function writeToCeramic() {
        // document.getElementById("provisioningStatus").innerText =
        //   "Provisioning, please wait...";

        const API_URL = "0.0.0.0:7007"; // "https://ceramic-clay.3boxlabs.com";
        const ceramic = new CeramicClient(API_URL);

        // assign DID to ceramic client..
        const resolver = { ...KeyDidResolver.getResolver() };
        const did = new DID({ resolver });
        console.log("did: ", did);
        ceramic.did = did;
        console.log("did assigned: ", ceramic.did);
        // console.log("did ID auth?: ", did.id());

        console.log("--------------------------------------");
        const seed = randomBytes(32);
        console.log("create seed: ", seed);
        const provider = new Ed25519Provider(seed);
        console.log("provide provider: ", provider);

        // assign provider to ceramic node that already has DID attached
        ceramic.did.setProvider(provider);

        const authing = async () => {
          const result = await ceramic.did.authenticate();
          // console.log(await ceramic.did.authenticate());
          console.log("authing...");
          return result;
        };
        console.log("highly evolved: ", authing.id);
        const doc = TileDocument.create(
          ceramic,
          { foo: "bart" },
          {
            controllers: [ceramic.did.id],
            family: "doc family",
            schema: schemaDoc.commitId
          }
        );
        console.log(doc);
        // const doc = async () => {
        //   tiledoc = await TileDocument.create(
        //     ceramic,
        //     { foo: "bart" },
        //     {
        //       controllers: [ceramic.did.id],
        //       family: "doc family",
        //       schema: schemaDoc.commitId
        //     }
        //   );
        //   return tiledoc;
        // };
        // console.log(doc);
        // const streamId = doc.id.toString();
        // console.log("streamID: ", streamId);

        //
        //
        //
        //
        //

        // window.accessControlConditions = [
        //   {
        //     contractAddress: LitJsSdk.LIT_CHAINS[window.chain].contractAddress,
        //     standardContractType: "ERC1155",
        //     chain: window.chain,
        //     method: "balanceOf",
        //     parameters: [":userAddress", window.tokenId.toString()],
        //     returnValueTest: {
        //       comparator: ">",
        //       value: "0"
        //     }
        //   }
        // ];

        // generate a random path because you can only provision access to a given path once

        // TODO: this is of interest for decrypt compare
        // await litNodeClient.saveSigningCondition({
        //   accessControlConditions: window.accessControlConditions,
        //   chain: window.chain,
        //   authSig: window.authSig,
        //   resourceId: window.resourceId
        // });

        document.getElementById("provisioningStatus").innerText =
          "Provisioned!";
      }

      // Query Ceramic and get previously saved data
      async function query() {
        document.getElementById("requestingStatus").innerText =
          "Requesting JWT, please wait...";

        window.jwt = await litNodeClient.getSignedToken({
          accessControlConditions: window.accessControlConditions,
          chain: window.chain,
          authSig: window.authSig,
          resourceId: window.resourceId
        });

        document.getElementById("requestingStatus").innerText =
          "JWT Obtained!  It is  " + window.jwt;
      }

      async function decryptWithLit() {
        // Get an auth sig from user (probably again but yeah)
        const authSigD = await LitJsSdk.checkAndSignAuthMessage({
          chain: "ethereum"
        });
        const acc = window.accessControlConditionsSave;
        const esk = window.encryptedSymmetricKeySave;
        const encryptedZip = window.encryptedZipSave;
        // get that symm key from previously saved details and auth sig
        console.log("_________________________");
        console.log(acc);
        console.log(esk);
        console.log(encryptedZip);
        console.log("_________________________");
        console.log(authSigD);
        console.log("_________________________");

        const objacc =
          '[{"contractAddress":"","standardContractType":"","chain":"ethereum","method":"eth_getBalance","parameters":["0x20598860Da775F63ae75E1CD2cE0D462B8CEe4C7","latest"],"returnValueTest":{"comparator":">=","value":"10000000000000"}}]';
        const symmKey = window.litNodeClient.getEncryptionKey({
          objacc, // does this need to be a string?  currently getting undefined
          toDecrypt: esk,
          chain,
          authSigD
        });
        console.log("decrypting... \n\n ", window.encryptedZipSave);

        const decryptedFiles = await decryptZip(
          window.encryptedZipSave,
          symmKey
        );
        const decryptedString = await decryptedFiles["string.txt"].async(
          "text"
        );
        console.log("decrypt: ", decryptedString);

        document.getElementById("verificationStatus").innerText =
          "Decrypting, please wait...";
        // const data = await fetch("/verify?jwt=" + window.jwt).then(resp =>
        //   resp.json()
        // );
        document.getElementById("verificationStatus").innerText =
          "Verified!  Response is \n" + response;

        // document.getElementById("verificationNote").style = "display: block;";
      }
    </script>
  </head>

  <body>
    <h1>
      LIT Protocol /+ Ceramic Network Integration
    </h1>
    <button id="ping" type="button" style="display: inherit; margin: 20px auto">
      Connect wallet
    </button>
    <input type="button" onclick="ping()" value="Display" />

    <h2>Step 1: Encrypt your file with LIT!</h2>
    Chain to encrypt on:
    <select id="selectedChain">
      <option value="ethereum" selected>Ethereum</option>
      <option value="fantom">Fantom</option>
      <option value="polygon">Polygon</option>
      <option value="xdai">xDai</option>
    </select>
    <br />
    <br />
    <button onclick="encryptWithLit()">Encrypt!</button>
    <br />
    <br />
    <div id="mintingStatus"></div>

    <h2>Step 2: Write on Ceramic!</h2>
    <button type="button" onclick="ping">
      Send to Ceramic Network
    </button>
    <br />
    <br />
    <div id="provisioningStatus"></div>

    <h2>Step 3: Query from Ceramic!</h2>
    <button onclick="query()">Query from Stream</button>
    <br />
    <br />
    <div id="requestingStatus"></div>

    <h2>Step 4: Decrypt with Lit Protocol!</h2>
    <button onclick="decryptWithLit()">Decrypt!</button>
    <br />
    <br />
    <pre id="verificationStatus"></pre>
    <br />
    <p id="verificationNote" style="display: none;">
      Replace this with something relevant---the "verified" variable is a
      boolean that indicates whether or not the signature verified properly.
    </p>
  </body>
</html>
